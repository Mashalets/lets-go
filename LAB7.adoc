:description: Лабораторная работа 7 
:toc: 
:toclevels: 3
:toc-title: Оглавление
:sectnums: |,all|
:figure-caption: Рисунок
:imagesdir: PIC
:table-caption: Таблица

include::Tityale7.adoc[]

== Таймеры для платы STM32F411RET6

Микроконтроллер *STM32F411RET6* включает в себя несколько типов таймеров, каждый из которых выполняет различные задачи, такие как измерение времени, генерация ШИМ-сигналов, захват и сравнение сигналов, а также управление периферийными устройствами. Все таймеры в STM32F411RET6 могут быть использованы для выполнения задач с высокой точностью и гибкостью.

1.Cистемный таймер (SysTick)

*SysTick* — это 24-битный таймер, встроенный в ядро Cortex-M4, который используется для создания периодических прерываний с фиксированным интервалом. Он широко применяется для задач с системным временем, таких как реализация операционных систем реального времени (_RTOS_) или для функции задержки в библиотеке HAL (_HAL_Delay_).

* Работает от тактового сигнала процессора (*HCLK*) или с делением на 8 для уменьшения частоты и энергопотребления.
* Управление таймером осуществляется через два основных регистра:
* *SYST_RVR (Reload Value Register)* — задаёт период таймера, определяя максимальное значение счётчика.
* *SYST_CSR (Control and Status Register)* — включает таймер, выбирает источник тактирования и управляет прерываниями.
* Таймер генерирует прерывание, когда счётчик достигает нуля, что позволяет выполнять периодические задачи.

2.Общие таймеры (General-Purpose Timers)

Эти таймеры универсальны и могут использоваться для решения широкого круга задач, включая измерение времени, захват сигналов и генерацию ШИМ.

* *TIM2* и *TIM5* — 32-битные таймеры, которые подходят для работы с длительными временными интервалами и более точными задачами, такими как синхронизация событий.
* *TIM3* и *TIM4* — 16-битные таймеры, предназначенные для менее сложных задач, таких как генерация ШИМ-сигналов и базовые временные интервалы.

3.Расширенные таймеры (Advanced-Control Timers)

*TIM1* — 16-битный таймер с расширенными возможностями для управления двигателями, генерации сложных ШИМ-сигналов и синхронизации. Он поддерживает функции, такие как вставка dead-time (время без действия) и комплементарные выходы, что делает его идеальным для применения в приложениях, требующих точной синхронизации.

4.Базовые таймеры (Basic Timers)

* *TIM6* и *TIM7* — 16-битные таймеры, которые выполняют простые задачи, такие как генерация периодических прерываний или триггеров для других периферийных устройств. Они не требуют внешних сигналов, что делает их удобными для применения в простых приложениях.

5.Специализированные таймеры (Specialized Timers)

* *TIM9*, *TIM10* и *TIM11* — 16-битные таймеры, используемые для специфичных задач, таких как управление аудиопотоками или сложной временной синхронизации в приложениях с менее строгими требованиями к частоте.

*Основные функции таймеров:*

* Генерация ШИМ-сигналов: Таймеры могут генерировать сигналы широтно-импульсной модуляции, что полезно для управления моторами, светодиодами или другими нагрузками.

* Захват и сравнение сигналов: Позволяют измерять длительность импульсов и сравнивать значения счётчиков с заранее заданными.

* Синхронизация событий: Таймеры могут синхронизировать работу других периферийных устройств, например, АЦП или DAC.

* Генерация прерываний: Таймеры могут генерировать прерывания по истечении заданного времени или при достижении определённых значений.

*Управление таймерами:*

Каждый таймер в STM32F411RET6 может быть настроен через регистры для выполнения различных функций. Для таймера **SysTick**, например, управление осуществляется через **SYST_RVR** и **SYST_CSR**, где задаются параметры работы таймера, источник тактирования и генерация прерываний. В других таймерах также используются аналогичные механизмы для настройки периода работы и обработки прерываний.

Таким образом, микроконтроллер STM32F411RET6 предлагает разнообразные таймеры с широким спектром возможностей для решения задач, связанных с измерением времени, генерацией сигналов и синхронизацией периферийных устройств, что позволяет эффективно использовать их в различных приложениях.

== Функция delay() с тактированием от STK

[source, cpp]
----
std::uint32_t SystemCoreClock = 13'333'000U;

void delay(std::uint32_t timeInMs)
{
  assert(timeInMs < 10000);
    // 1. Посчитать значение задержки
  const auto timerDelayCounts = (SystemCoreClock / 1000U) * timeInMs;
    // 2. Записать в регистре LOAD значение задержки
  STK::LOAD::Write(timerDelayCounts - 1);
    // 3. Сброс текущего значения таймера
  STK::VAL::Write(0);
    //4. Включить системный таймер в регистре CTRL
  STK::CTRL::ENABLE::Enable::Set();
    //5. Ожидание окончания задержки
  while(STK::CTRL::COUNTFLAG::NoOverflow::IsSet())
  {
  }
    // 6. Отключить системный таймер в регистре CTRL
  STK::CTRL::ENABLE::Disable();
}
----

Этот код реализует функцию задержки, используя системный таймер микроконтроллера. Он использует встроенные механизмы для создания паузы в программе на заданное количество миллисекунд. 

. Вычисление количества тактов для задержки: (SystemCoreClock / 1000U) — вычисляется количество тактов в 1 миллисекунду. Умножив это значение на timeInMs, мы получаем количество тактов, которое требуется для задержки в миллисекундах.

. Запись в регистр LOAD значения задержки: значение задержки записывается в регистр LOAD системного таймера. В данном случае, таймер должен отсчитывать количество тактов, которое было вычислено на предыдущем шаге. Значение в регистре LOAD должно быть на единицу меньше, потому что таймеры часто начинают отсчёт с нуля.

. Сброс текущего значения таймера: этот шаг сбрасывает текущий счётчик таймера, чтобы начать отсчёт с нуля.

. Включение системного таймера: включается системный таймер путём установки соответствующего бита в регистре CTRL.

. Ожидание окончания задержки: этот цикл выполняется до тех пор, пока не завершится отсчёт времени. Проверяется флаг COUNTFLAG, который указывает на завершение отсчёта таймера. Когда флаг NoOverflow сбрасывается, задержка завершена, и программа выходит из цикла.

. Отключение системного таймера: после завершения задержки таймер отключается, чтобы избежать его дальнейшей работы.

== Функция delay() с тактированием от TIM5

[source, cpp]
----
void delay(std::uint32_t timeInMs)
{
    1. Проверка входного параметра
  assert(timeInMs < 10000);
    2. Посчитать значение задержки
  const auto prescalerValue = SystemCoreClock / 1000U;
    3. Настройка предделителя
  TIM2::PSC::Write(prescalerValue - 1U);
    4. Настройка режима таймера
  TIM2::CR1::URS::Value1::Set();
    5. Настройка значения автоперезагрузки
  TIM2::ARR::Write(timeInMs);
    6. Сброс флага обновления
  TIM2::SR::UIF::Set(0);
    7. Сброс текущего значения счетчика
  TIM2::CNT::Write(0);
    8. Запуск таймера
  TIM2::CR1::CEN::Enable::Set();
    9. Ожидание завершения задержки
  while(TIM2::SR::UIF::NoInterruptPending::IsSet())
  {
  }
    10. Остановка таймера
  TIM2::CR1::CEN::Disable::Set();
}
----

Этот код реализует функцию задержки на основе таймера TIM2. Она настраивает таймер для отсчёта времени в миллисекундах, используя предделитель и авто-перезагрузку, а затем ждёт завершения отсчёта перед тем, как остановить таймер. 

. Проверка входного параметра: проверяется, что значение timeInMs меньше 10 000 миллисекунд (10 секунд). Это гарантирует, что задержка не будет слишком длинной, чтобы избежать ненужных ошибок.

. Рассчёт значения предделителя: prescalerValue рассчитывается как отношение тактовой частоты системы (SystemCoreClock) к 1000. Это значение используется для настройки предделителя, чтобы таймер отсчитывал миллисекунд

. Настройка предделителя таймера: регистр PSC (Prescaler) таймера TIM2 настраивается так, чтобы счётчик таймера увеличивался с частотой, соответствующей 1 миллисекунде. Для этого устанавливается предделитель, который уменьшает частоту тактового сигнала, подаваемого на таймер.

. Настройка режима таймера: в регистре CR1 таймера TIM2 устанавливается бит URS (Update Request Source) в значение 1, что означает, что обновление (перезагрузка) таймера будет происходить только при переполнении счётчика (при достижении значения авто-перезагрузки).

. Настройка значения авто-перезагрузки: в регистре ARR (Auto-Reload Register) записывается значение timeInMs, которое задаёт количество миллисекунд задержки. Как только таймер достигает этого значения, он генерирует событие обновления (переполнение).

. Сброс флага обновления: сбрасывается флаг UIF (Update Interrupt Flag) в регистре SR (Status Register) таймера TIM2. Это необходимо для того, чтобы предотвратить обработку предыдущих прерываний или флагов, которые могли быть установлены до этого. 

. Сброс текущего значения счётчика: сбрасывается текущее значение счётчика таймера CNT, чтобы отсчёт времени начинался с нуля.

. Запуск таймера: включается таймер TIM2 путём установки бита CEN (Counter Enable) в регистре CR1, что запускает отсчёт времени.

. Ожидание завершения задержки: этот цикл ожидает завершения задержки. Он продолжает выполняться, пока не будет установлен флаг UIF в регистре SR таймера TIM2, что указывает на завершение задержки и переполнение таймера.

. Остановка таймера: после завершения задержки таймер TIM2 отключается путём сброса бита CEN в регистре CR1, что останавливает его.

== Заключение

В данной лабораторной работе были изучены встроенные таймеры для платы STM32F411RET6. Подробно рассмотрели два подхода (использование SysTick и TIM2) показывают, как можно использовать разные таймеры для создания задержек. Преимущества SysTick в простоте и быстроте реализации, в то время как TIM2 даёт больше гибкости и точности, что важно для более сложных задач.