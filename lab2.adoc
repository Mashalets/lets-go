= Лабораторная работа 2
:author: Горшунова Мария Андреевна КЭ - 413
:description: Лабораторная работа 2
:toc: 
:toclevels: 3
:toc-title: Оглавление
:sectnums: |,all|
:figure-caption: Рисунок
:imagesdir: PIC
:table-caption: Таблица

== Типы данных

Типы данных - это категории, которые определяют, какие значения могут храниться в переменной и какие операции могут быть выполнены с этими значениями. Основные типы данных, которые существуют в большинстве языков программирования представлены на рисунке <<Типы_данных_в_С++>>

[#Типы_данных_в_С++]
.Типы данных в С++
image::Типы данных в С++.png[]

=== Встроенные типы

[#Встроенные типы С++]
.Встроенные типы С++
[options="header"]
|===
|Тип | Длина |Комментарий
|*bool*| 1| Представляет значения, которые могут быть или *true*, или *false*.
|*char*|1	| Используется для символов ASCII в старых строках в стиле C или в объектах std::string,
которые никогда не будут преобразовываться в Юникод.
|*unsigned char*| 1 |	Аналог байта. В С++17 стандарте появился тип std::byte
|*int*|	4 |Целочисленное значение. Выбор по умолчанию для целых чисел
|*unsigned int*| 4| Беззнаковое целое число
|*float*| 4	|Число с плавающей точкой, поддерживается аппаратно некоторыми микроконтроллерами
|*double*| 8	|Число с плавающей запятой двойной точности. Выбор по умолчанию для значений с плавающей
точкой
|===

=== Модификаторы типов данных

[#Встроенные типы С++ модификаторы]
.Встроенные типа С++ модификаторы
[options="header"]
|===
|Тип | Длина |Комментарий
|*short int*|	2|Целочисленное знаковое значение укороченной длины
|*unsigned short int*| 2|	Целочисленное беззнаковое значение укороченной длины
|*long int*|	8|Выбор по умолчанию для целочисленных значений. На платформах на которых int равен по
длине unsigned short int может быть длиннее int
|*unsigned long int*|8	|Целое число двойной длины. На платформах на которых int равен по длине unsigned short int может быть
длиннее int
|*long double*|8	|Число с плавающей точкой двойной точности	с двойной точностью 
|===

=== Почему нельзя смешивать типы между собой?

Смешивание типов в C++ может привести к непредсказуемому поведению программы, потому что разные типы данных занимают разное количество памяти и интерпретируются по-разному. Когда происходит неявное преобразование одного типа в другой, компилятор может некорректно интерпретировать данные, что может привести к ошибкам и багам.

[source, cpp]
----
#include <iostream>
using namespace std;

int main() {
int a = 10;
double b = 3.5;
int c = a + b; // Здесь мы складываем int и double

cout « "Результат: " « c « endl;
return 0;
}
----

* Переменная a имеет тип int, а переменная b - double.
* При сложении компилятор автоматически приведет a к double, чтобы выполнить операцию с b, и результат будет double.
* Однако переменная c имеет тип int, и при присваивании double к int дробная часть будет отброшена.

Можно сделать вывод:

* Ожидаемый результат сложения 10 + 3.5 = 13.5.
* Но в c сохранится только целая часть: 13.

Вывод программы:

Результат: 13

Проблема:

* Потеря данных (дробной части) при неявном преобразовании типов может вызвать неожиданные результаты.
* Это особенно важно, если точность расчетов критична.

=== Функции преобразования

Функции преобразования - это специальные методы, которые позволяют объектам одного типа автоматически преобразовываться в другой тип. Они могут быть использованы для неявного или явного преобразования типов. Рассмотрим подробнее оба подхода.

==== Неявное преобразование типов
Базовые/простые типы неявно можно привести друг к другу. Т.е

[source, cpp]
----
int a = 0; 

char a = 512; 

int a = 3.14;  

bool a = -4;  

bool a  = 0;  
----

. Присваимаем знаковое целое(int) число переменной целого типа
. Присваиваем знаковое целое(int) число переменной типа char. Результат в а 0 ;
. Присваиваем число с плавающей точкой(double) к переменной типа int. Результат в а 3
. Присваиваем знаковое целое(int) к переменной типа bool. Результат в а true
. Присваиваем знаковое целое(int) к переменной типа bool. Результат в а false

==== Явное преобразование типов
Так как компилятор может сделать за вас, то, что вы вообще не ожидаете, не нужно использовать неявное
преобразование типа.

Вместо этого, лучше указать компилятору явное преобразование из одного типа в другой.
В этом случае, вы говорите компилятору, что я понимаю, что я делаю, это именно так и задумано

Для преобразований из одного типа используют 4 вариантов преобразования:

* static_cast
* const_cast
* reinterpret_cast
* dynamic_cast

==== static_cast

static_cast позволяет сделать приведение близких типов (целые, пользовательских типов которые могутсоздаваться из типов который приводится, и указатель на void* к указателю на любой тип).

Проверка производится на уровне компиляции, так что в случае ошибки сообщение будет получено в момент сборки приложения или библиотеки.

[source, cpp]
----
int a = static_cast<int>(0); 

int a = static_cast<int>(3.14);  

bool a = static_cast<bool>(-4);  

bool a  = static_cast<bool>(0);  

float f = 3.14f ;     

float f = static_cast<float>(3.14) ;  

Complex f = static_cast<3.14> 
----

. Явно говорим, что 0 должен восприниматься как тип (int), хотя он и так является литералом типа int.
. Явно говорим, что 3.14 воспринимать как int, т.е взять только целую часть.
. Явно говорим, -4 нужно воспринять как bool тип, в данном случае true.
. Явно говорим, 0 нужно воспринять как bool тип, в данном случае false.
. Явно говорим, что 3.14 это float
. Явно говорим, что 3.14 это float
. Комплексное число может создаться из double, поэтому тут будет работать static_cast.

==== reinterpret_cast

reinterpret_cast преобразует типы, несовместимыми друг с другом, и используется для:

* В свой собственный тип
* Указателя в интегральный тип
* Интегрального типа в указатель
* Указателя одного типа в указатель другого типа
* Указателя на функцию одного типа в указатель на функцию другого типа

[source, cpp]
----
auto ptr = reinterpret_cast<volatile uint32_t *>(0x40010000) ; # <1>
auto value = *ptr ; #<2>
----

. Преобразует адрес 0x40010000 в указатель типа volatile uint32_t
. Записывает в переменную value (типа) значение лежащее по указателю ptr, указывающего на адрес 0x40010000

=== Размеры типов данных
Размеры типов не четко определены и могут отличаться для различных микроконтроллеров. Для размеров типов существует правило:

[source, cpp]
----
1             <= sizeof(char)     <= sizeof(short) <= sizeof(int) <= sizeof(long)
1             <= sizeof(bool)     <= sizeof(long)
sizeof(char)  <= sizeof(long)
sizeof(float) <= sizeof(double)   <= sizeof(long double)
sizeof(T)     == sizeof(signed T) == sizeof(unsigned T)
----

Поэтому вместо прямых типов типа int, используются псевдонимы, которые представлены в таблице <<Псевдонимы>> :

[#Псевдонимы]
.Псевдонимы
|===
|std::uint8_t::	беззнаковое целое длиной 8 бит
|std::int8_t:: знаковое целое длиной 8 бит
|std::uint16_t:: беззнаковое целое длиной 16 бит
|std::int16_t::	знаковое целое длиной 16 бит
|std::uint32_t:: беззнаковое целое длиной 32 бита
|std::int32_t::знаковое целое длиной 32 бита
|std::uint64_t::	беззнаковое целое длиной 64 бита
|std::int64_t::	знаковое целое длиной 64 бита
|std::uint_least8_t::	минимальное целое беззнаковое, не меньше 8 бит
|std::int_least8_t::	минимальное целое знаковое, не меньше 8 бит
|std::uint_least16_t::	минимальное целое беззнаковое, не меньше 16 бит
|std::int_least16_t::	минимальное целое знаковое, не меньше 16 бит
|std::uint_least32_t::	минимальное целое беззнаковое, не меньше 32 бит
|std::int_least32_t::	минимальное целое знаковое, не меньше 32 бит
|std::uint_least64_t::	минимальное целое беззнаковое, не меньше 64 бит
|std::int_least64_t::	минимальное целое знаковое, не меньше 64 бит
|std::uint_fast8_tм	быстрое целое беззнаковое, не меньше 8 бит
|std::int_fast8_t::	быстрое целое знаковое, не меньше 8 бит
|std::uint_fast16_t::	быстрое целое беззнаковое, не меньше 16 бит
|std::int_fast16_t::	быстрое целое знаковое, не меньше 16 бит
|std::uint_fast32_t::	быстрое целое беззнаковое, не меньше 32 бит
|std::int_fast32_t::	быстрое целое знаковое, не меньше 32 бит
|std::uint_fast64_t::	быстрое целое беззнаковое, не меньше 64 бит
|std::int_fast64_t::	быстрое целое знаковое, не меньше 64 бит
|std::intptr_t::	целое, достаточное для хранения указателя
|std::uintptr_t::	беззнаковое целое, достаточное для хранения указателя
|===

=== Почему использование встроенных типов плохо?

Использование встроенных типов данных не всегда плохо, но в определённых случаях может быть ограничивающим:

. Ограниченная гибкость: Встроенные типы могут не охватывать все специфические требования задачи. Например, для сложных структур данных (графы, деревья) встроенные типы не подходят напрямую.
. Слабая выразительность: Встроенные типы не всегда могут выразить логику или структуру данных программы (например, тип "денежная сумма" требует дополнительных проверок, которых нет в float или int).
. Меньшая безопасность: Примитивные типы данных не могут иметь встроенные проверки правильности значений. Пользовательские типы могут внедрять валидацию, обеспечивая больше контроля.
. Сложность поддержки и масштабирования: Встроенные типы могут затруднять поддержку и модификацию программы, если требуется расширить или изменить логику обработки данных.

=== Как распределяется память ОЗУ в микроконтроллере?

Память ОЗУ на микроконтроллере распределяется на несколько этапоп:

. Стек - для хранения локальных переменных и адресов возврата.
. Куча - для динамического выделения памяти.
. Глобальные и статические переменные - для данных, доступных в течение всей программы.
. Память периферийных устройств  для работы с устройствами ввода/вывода.

Такое разделение оптимизирует работу с памятью и предотвращает ошибки.

=== Память 

Память разделена на три типа:

* ПЗУ  (FLASH память в которой храниться программа)
* ОЗУ память для хранения временных данных (туда же можно по необходимости переместить программу и выполнить её из ОЗУ), память в которой находятся регистры отвечающие за настройку и работу с периферией и
* Память для хранения постоянных данных ЕЕPROM.

Адресное пространство памяти программы (ПЗУ) находится по адресам *0x00000000* по *0x1FFFFFFF*

Адресное пространство ОЗУ находится по адресам  *0x20000000* по *0x3FFFFFFF*

==== Память для расположения данных

Данные в памяти могут быть расположены 3 различными способами:

* Авто(локальные) переменные, которые являются локальными в функции располагаются в регистрах или в стеке.

Такие переменные "существуют" только внутри функции, как только функция закончится и вернется к вызывающему
объекту, эти переменные становятся не валидными.

* Глобальные переменные или статические переменные. В этом случае они инициализируются единожды.

Static означает, что та память, которая была выделена под эту переменную не будет изменяться и
закрепляется за этой переменной до конца работы приложения.

* Динамически размещаемые данные. Данные создаваемые на Куче(Heap)

Если заранее не известно, сколько объектов нужно создать, и сколько памяти они будут отнимать, то придется
создавать их динамически, например с помощью оператора new, в таком случае, объекты будут создаваться в куче.

Память под функции(команды)

Для расположения функций используется та же самая память с границами от *0x00000000 - 0xFFFFFFFF*.

По умолчанию весь код будет лежать в сегменте .text, который расположен в readonly памяти (обычно в ROM), но можно разместить функции и в ОЗУ.

=== Указатели

Как мы уже поняли, данные могут находится в ОЗУ или ПЗУ. Каждой переменной содержащей данные соответствует некий адрес памяти. К переменной можно обратиться непосредственно обращаясь к самой переменной, тогда мы можем напрямую писать или читать значение с адреса переменной, либо можно обратиться косвенно, через указатель или ссылку.

Указатель это переменная, которая хранит адрес какой-то другой переменной:

[source, cpp]
----
int main() {
  int  c = 463 ;   
  int* ptr = &c ;  
  return 0;
}
----

. Объявляем переменную c типа int
. Объявляем указатель ptr на переменную c типа int

[#Указатель]
.Указатель
image::Указатель.png[]

=== Операции над указателями

Указатели можно складывать, вычитать, сравнивать. Но указатели должны быть одного типа. Т.е. не нужно например складывать укатель типа char и int.

[source, cpp]
----
int main() {
  int  arr[] = {1,2,3,4,5} ;    
  int* ptr = arr ;              

  ptr ++ ;                     
  int a = *(ptr + 4) ;         
  if(ptr != nullptr)            
    cout << a << ": " << *ptr; 
}
----

. Объявление массива *arr* из 5 элементов. В целом можно считать, что массив *arr* это указатель на первый элемент массива.
. Обявления указателя на массив типа *int* ;
. Увеличиваем указатель на 1. На самом деле мы смещаемся по адресам на размер равный *size_of(int)*, т.е. на 4 байта. Т.е в данном случае указатель *ptr* стал указывать на элемент массива *arr[1]*.
. Объявляем переменную *а* типа *int* и присваиваем ей значение *аrr[4]*.
. Сравнение указателя с nullptr указателем.
. Вывод значения *а* и значения по адресу в указателе *ptr*. Вывод (5: 2)

=== Изменение ячейки памяти

Для изменения любой ячейки памяти можно использовать указатели.Это позволяют работать напрямую с адресами памяти.

. Определение указателя: Указатель хранит адрес ячейки памяти, к которой можно обратиться для изменения данных.
. Изменение значения по адресу: С помощью указателя можно изменять значение в ячейке памяти, используя оператор разыменования (*).

Пример изменения значения переменной через указатель:

[source, cpp]
----
#include <iostream>

int main() {
int value = 10;
int* ptr = &value; // Указатель на адрес переменной `value`

std::cout « "Before: " « value « std::endl;

*ptr = 20; // Изменение значения по адресу

std::cout « "After: " « value « std::endl;

return 0;
}
----

Вывод:

[source, cpp]
----
Before: 10
After: 20
----

Пример изменения значения в конкретной ячейке памяти:

Если нужно изменить конкретный адрес в памяти (например, адрес периферийного устройства или выделенной области памяти), это можно сделать следующим образом:

[source, cpp]
----
#include <iostream>

int main() {
int* ptr = (int*) 0x20000000; // Прямое указание адреса (пример)

*ptr = 42; //  Разыменование указателя

return 0;
}
----

Прямое изменение произвольных адресов может быть опасно и привести к сбоям, если эти адреса не принадлежат программе или используются системой.

=== Задания

*Если указатель типа Int указывает на адрес 1 и к этому указателю прибавит 1, то на какой адрес будет указывать указать и почему? А если указатель будет типа double*

Прибавление единицы к указателю перемещает его на следующий элемент того типа, на который он указывает. Размер этого смещения зависит от типа данных.

* Указатель типа int

Если указатель типа int указывает на адрес 1, и к нему прибавить 1, то новый адрес будет не 2, а:

В C++ смещение указателя учитывает размер типа. Если размер типа int составляет 4 байта (на большинстве современных систем), то указатель сдвинется на 4 байта.

Пример:

[source, cpp]
----
int* ptr = (int*)1; // Указатель на адрес 1
ptr = ptr + 1; // Прибавляем 1
----

Теперь указатель будет указывать на адрес 1 + 4 = 5, так как размер int — 4 байта.

* Указатель типа double

Если указатель типа double указывает на адрес 1, и к нему прибавить 1, то новый адрес будет смещен на размер double.

В C++ тип double обычно занимает 8 байт (зависит от системы). Поэтому при прибавлении 1 указатель сдвинется на 8 байт.

Пример:

[source, cpp]
----
double* ptr = (double*)1; // Указатель на адрес 1
ptr = ptr + 1; // Прибавляем 1
----

Теперь указатель будет указывать на адрес 1 + 8 = 9, так как размер double — 8 байт.

Вывод:

* Указатель на int сдвинется на 4 байта.
* Указатель на double сдвинется на 8 байт.

Размер смещения зависит от размера типа, на который указывает указатель.

*Если в ячейке по адресу 1 лежит число 10, в ячейке по адресу 2 лежит число 20, в ячейке по адресу 3 лежит число 30, в ячейке по адресу 4 лежит число 40 и если у нас указатель типа std::uint32_t указывает на адрес 1, то какое число будет в переменной b после разыменовывания указателя?*

[source, cpp]
----
std::uint32_t* ptr = reinterpret_cast<std::uin32_t>(1);
auto b = *ptr; //чему равно b?
----

Чаще всего используется little-endian порядок байт, где младший байт (число 10) хранится по младшему адресу (адрес 1), а старшие байты по старшим адресам. На системах с порядком байт little-endian эти байты образуют число: 673720842. Значение переменной b после разыменовывания равно 673720842.

*Если в ячейке по адресу 1 лежит число 10, в ячейке по адресу 2 лежит число 20, в ячейке по адресу 3 лежит число 30, в ячейке по адресу 4 лежит число 40 и если у нас указатель типа std::uint16_t указывает на адрес 1, то какое число будет в переменной b после разыменовывания указателя?*

[source, cpp]
----
std::uint16_t* ptr = reinterpret_cast<std::uin16_t>(1);
auto b = *ptr; //чему равно b?
----

Если указатель типа std::uint16_t указывает на адрес 1, он прочитает только 2 байта: 10 и 20. Эти байты дадут число 5130.

*// auto b = "c"; Какого типа b?*

Переменная b будет типа const char*, что означает, что она указывает на строку, которую нельзя изменить. Это происходит, потому что строка в двойных кавычках ("c") воспринимается как массив символов, и компилятор автоматически превращает её в указатель на первый символ этого массива.

*// auto b1 = 'c'; Какого типа b1?*  

Переменная b1 будет иметь тип char.

*// char a = 'A'; В какое число переведется символ А*

Символ A переведется в число 65.

=== Регистр

Существуют регистры общего назначения и специальные регистры. Регистры общего назначения расположены внутри ядра микроконтроллера(сверхбыстрая память).

Регистры общего назначения - это сверхбыстрая память внутри процессора, предназначенная для хранения адресов и промежуточных результатов вычислений (регистр общего назначения/регистр данных) или данных, необходимых для работы самого процессора.

Регистры специального назначения расположены в ОЗУ микроконтроллера и используются для управленияпроцессором и периферийными устройствами.

Каждый регистр в архитектуре ARM представляет собой ресурс памяти и имеет длину в 32 бита, где каждый бит можно представить в виде выключателя с помощью которого осуществляется управление тем или иным параметром микроконтроллера.

==== Как поменять значение регистра? 

Чтобы поменять значение регистра в языке программирования на уровне низкоуровневого программирования, можно использовать указатели для доступа к определённым адресам памяти, где хранится значение регистра.

[source, cpp]
----
#include <cstdint>
#include <iostream>

volatile std::uint32_t* register_ptr = reinterpret_cast<std::uint32_t*>(0x40000000); // Адрес регистра

*register_ptr = 0x01; // Изменение значения регистра на 1
----

. volatile: Ключевое слово volatile сообщает компилятору, что значение может изменяться вне текущего контекста, например, аппаратным обеспечением.
. reinterpret_cast: Используется для приведения адреса к нужному типу указателя.
. Разыменование: *register_ptr = 0x01; изменяет значение регистра по указанному адресу.

=== Логические опрераторы

Логические операторы предоставляют действия над булевым типов. Результат действия этих операторов может быть только true или false.

* && — логическое «И» или логическое умножение (конъюнкция). Оператор И возвращает истину, если верны оба утверждения.
* || — логическое «ИЛИ» или логическое сложение (дизъюнкция). Оператор ИЛИ возвращает истину, если верно хотя бы одно утверждение.

[#Логические операторы]
.Логические операторы
[options="header"]
|===
|Операция | Оператор | Комментарий | Пример
|Логическое умножение, И    | &&    | a && b| true && false => false
|Логическое сложение, ИЛИ   | &#124;&#124;  |   a &#124; &#124;  b  | true &#124; &#124;  false => true
|===

==== Как сбросить бит? 

* **&=*  оператор, который выполняет побитовую операцию "И" с инверсией бита, который нужно сбросить
* *~*  оператор побитового отрицания, который инвертирует биты

Эти примеры позволят вам эффективно сбросить бит в нужной переменной или регистре.






