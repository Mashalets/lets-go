:description: Лабораторная работа 3-4 
:toc: 
:toclevels: 3
:toc-title: Оглавление
:sectnums: |,all|
:figure-caption: Рисунок
:imagesdir: PIC
:table-caption: Таблица

include::Tityale3_4.adoc[]

== Принцип Single Responsibility

Принцип Single Responsibility утверждает, что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс, а все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.

Следование принципу заключается обычно в декомпозиции сложных классов, которые делают сразу много вещей, на простые, отвественность которых очень специализирована. Но также и объединении в отдельный класс однотипной функциональности, которая может оказаться распределённой по многим классам, может рассматриваться как следование этому принципу.

Проектирование классов с направленностью на обеспечение единственной обязанности упрощает дальнейшие модификации и сопровождение, так как проще разобраться в одном блоке функциональности, нежели распутывать сложные взаимосвязи между различными функциональными блоками. Также при модификации логики в одном месте приложения снижаются риски возникновения проблем в других «неожиданных» его местах.

=== Пример Single Responsibility

Представим, что я работаю в офисе и выполняю два разных задания: отвечаю на звонки и сортирую почту.

Если я выполняю оба задания одновременно, и мне приходится постоянно переключаться между ними, и это усложняет работу.

*Нарушение принципа:*

* Я - один человек, который делает всё: отвечаю на звонки, а потом иду сортировать почту, и снова отвечаю на звонки. Мне сложно сосредоточиться на одной задаче, и я трачу больше времени.

*Применение принципа Single Responsibility:*

* Я - человек, отвечающий только на звонки. Я сосредоточена на звонках и делаю это быстро и эффективно.
* Мой коллега - человек, который сортирует почту. Он занимается только почтой, не отвлекаясь на звонки.

Теперь каждый из вас выполняет только одну задачу, и ваша работа становится более организованной и эффективной.

*Вывод*

Принцип единственной ответственности заключается в том, чтобы человек (или система) выполнял одну задачу, что упрощает работу, повышает эффективность и уменьшает ошибки.

== Включение светодиодов с помощью указателей

Указатель - это переменная, которая хранит адрес другой переменной. Указатели используются для управления памятью, взаимодействия с динамически выделяемыми данными, а также для эффективной передачи больших объектов или работы с массивами.

Напишем код который, поочередно включает светодиоды в порядке "елочки" - от LED1 до LED4, а затем в обратном порядке их выключение.

Светодиоды расположены на двух портах (GPIOA и GPIOC). На порте GPIOC находятся 3 светодиода, подключенные к битам 5, 8 и 9, а на порте GPIOA - 1 светодиод, подключенный к биту 5.

[source, cpp]
----
// Битовые маски
const std::uint32_t maskBit5 = (1U << 5U);
const std::uint32_t maskBit8 = (1U << 8U);
const std::uint32_t maskBit9 = (1U << 9U);

// Указание адресов портов
std::uint32_t* const prtGpiocOdr = reinterpret_cast<uint32_t*>(0x40020814U); // Порт GPIOC
std::uint32_t* const prtGpioaOdr = reinterpret_cast<uint32_t*>(0x40020014U); // Порт GPIOA

for(;;)
{
    // Включение светодиодов
    *prtGpioaOdr |= maskBit5; // Светодиод LED1
    delay(1000000);

    *prtGpiocOdr |= maskBit9; // Светодиод LED2
    delay(1000000);

    *prtGpiocOdr |= maskBit8; // Светодиод LED3
    delay(1000000);

    *prtGpiocOdr |= maskBit5; // Светодиод LED4
    delay(1000000);

    // Выключение светодиодов
    *prtGpioaOdr &= ~maskBit5; // Светодиод LED1
    delay(1000000);

    *prtGpiocOdr &= ~maskBit9; // Светодиод LED2
    delay(1000000);

    *prtGpiocOdr &= ~maskBit8; // Светодиод LED3
    delay(1000000);

    *prtGpiocOdr &= ~maskBit5; // Светодиод LED4
    delay(1000000);

    return 1;
}
----

Для расширения функциональных возможностей кода и упрощения его последующего редактирования и использования, мы воспользуемся другим подходом — реализуем класс.

== Включение светодиодов с помощью класса

Класс — это конструкция, которая позволяет объединить данные и методы (функции), работающие с этими данными, в одну логическую единицу. Класс является основой объектно-ориентированного программирования (ООП) и служит для создания объектов. Он описывает структуру и поведение объектов, а также инкапсулирует их внутреннее состояние.

Создадим класс обекта светодиод "Led":

[source, cpp]
----
// Создание виртуального класса
class ILed
{
    virtual void Light() = 0;
    virtual void Off() = 0;
    virtual void Toggle() = 0;
};

// Создание класса Led
class Led : public ILed
{
public:
    Led(std::uint32_t registerAddres, std::uint32_t pinNumber) : 
    registerAddr(registerAddres), pinNum(pinNumber) // Конструктор
    {
    }

void Light() override // Функция включения светодиода
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) |= (1 << pinNum);
    }
    void Off() override // Функция выключения светодиода
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) &= ~(1 << pinNum);
    }
    void Toggle() override // Функция изменения состояния светодиода на противоположное
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) ^= (1 << pinNum);
    }
private:
    std::uint32_t registerAddr; // Адрес указываемого регистра (порта)
    std::uint32_t pinNum; // Номер указываемого номера бита
};
----

Этот код создает интерфейс ILed, который определяет абстрактные методы для управления светодиодами: включение, выключение и переключение состояния. Класс Led реализует этот интерфейс, предоставляя конкретные функции для управления светодиодом через прямые манипуляции с регистрами микроконтроллера. Используются побитовые операции для включения, выключения и переключения состояния светодиода на заданном пине. Адрес регистра и номер пина передаются в конструктор класса.

Ниже написан код с зажиганием светодиодов "елочкой":

[source, cpp]
----
// Битовые маски
constexpr std::uint32_t maskBit5 = (1U << 5U);
constexpr std::uint32_t maskBit8 = (1U << 8U);
constexpr std::uint32_t maskBit9 = (1U << 9U);
// Указание портов
constexpr std::uint32_t gpiocOdrRegAddres = 0x40020814U;
constexpr std::uint32_t gpioaOdrRegAddres = 0x40020014U;
// Указатели
auto const gpioaOdrPtr = reinterpret_cast<std::uint32_t*>(gpioaOdrRegAddres);
auto const gpiocOdrPtr = reinterpret_cast<std::uint32_t*>(gpiocOdrRegAddres);

// Указание элементам массива (светодиодам) порта и бита
Led led1(gpioaOdrRegAddres, 5);
Led led2(gpiocOdrRegAddres, 9);
Led led3(gpiocOdrRegAddres, 8);
Led led4(gpiocOdrRegAddres, 5);

// Создание массива светодиодов
std::array<Led*, 4> leds = {
    &led1,
    &led2,
    &led3,
    &led4};

for(;;)
{
    for(auto it: leds)
    {
        it->Toggle(); // Включение/выключение светодиода
        delay(1000000);
    }
    
    return 1;
}
----

Таким образом, длинный и сложный код, написанный в начале работы, был сокращен до двух строк, выполняющих ту же задачу. Кроме того, такой подход значительно упрощает редактирование и расширение функциональности кода.

== Реализация других режимов включения светодиодов

В ходе лабораторной работы были также рассмотрены варианты включения светодиодов: "елочкой" (уже разобран), все одновременно и в шахматном порядке.

Таким образом, возникает еще одна задача: помимо указания порта и бита светодиода необходимо также указывать режим их работы.

Ниже представленна UML-диаграмма, показывающая обновленную структуру программы.

.UML-диаграмма
image::Diagramma.jpg[]

На диаграмме показано, что функции включения/выключения светодиода (*Light, Off, Toggle*) реализованы с помощью отдельного класса (интерфейса). То есть, функции включения/выключения реализованы отдельно. В свою очередь, режимы работы светодиодов имеют два метода: обновление (*Update()*) и установление (*Init()*). Каждый из этих методов реализован отдельно в соответствующих классах режимов.

=== Зажигание светодиодов в шахматном порядке

Светодиоды необходимо зажигать попеременно, т.е. два горят, два не горят.

Поскольку каждый из создаваемых режимов имеет две основные функции: обновление и установление, следует создать виртуальный класс, объявляющий данные методы:

[source, cpp]
----
class IMode
    {
      virtual void Update() = 0; // Обновление режима
      virtual void Init() = 0; // Установление режима
    };
----

Далее идет реализация класса, включающего светодиоды в шахматном порядке (класс *ChessMode*).

[source, cpp]
----
using tLeds = std::array<ILed*, 4>; // Создание массива указателей на объекты виртуального класса

class ChessMode: public IMode
    {
    public:
      ChessMode(tLeds& ledsArr): leds(ledsArr)
      {
      }
      // Метод обновления режима
      void Update() override
      {
        for(auto it: leds)
        {
          it->Toggle();
        }
      }
      
      // Метод установления режима
      void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        for(auto i=0; i< leds.size(); ++i)
        {
          if ((i%2)==0) // Условие четности
          {
            leds[i]->Toggle();
          }
        }
      }
    private:
      tLeds& leds;
    };
----

Благодаря виртуальному классу, методы, по сути выполняющие одни и те же функции, могут быть применены для многих других создаваемых режимов.

=== Одновременное зажигание включение светодиодов

Реализуем другой режим работы светодиодов, позволяющий зажигать светодиоды одновременно и одновременно выключать их.

[source, cpp]
----
class AllMode:public IMode
 {
 public:
    AllMode(tLeds& ledsArr): leds(ledsArr)
    {
        
    }
      void Update() override
      {
        for(auto it: leds)
        {
          it->Toggle();
        }
      }
      
      void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        
      }
private:
 tLeds& leds;
 };
----

=== Зажигание светодиоды в режиме "елочки"

Ниже реализуем режим работы светодиодов "елочкой".

[source, cpp]
----
class TreeMode:public IMode
 {
 public:
    TreeMode(tLeds& ledsArr): leds(ledsArr)
    {
        
    }
  void Update() override
  {  
    leds[currentLedIndex]->Switch();
    currentLedIndex++;
    if(currentLedIndex >= leds.size())
    {
      currentLedIndex=0;
    }
  }  
    
  void Init() override
  { 
    currentLedIndex=0;
    for(auto it: leds)
     {   
          it->Light();
     }   
 
   }   
    private:
      tLeds& leds;
      std::size_t currentLedIndex;
    };

      for(;;)
    
int main()
{  
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOA::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;

  
  Led<GPIOC, 5> led1;
  Led<GPIOC, 8> led2;
  Led<GPIOC, 9> led3;
  Led<GPIOA, 5> led4;

  
   tLeds leds = {
    &led1,
    &led2,
    &led3,
    &led4};

    TreeMode treemode(leds);
    treemode.Init();

  for(;;)
  {

   treemode.Update();
  
  }

}
----

== Вывод 

В данной лабоараторной работе, мы расмотрели принцип Single Responsibility, а так же были рассмотрены различные реализации программ, с помощью классов. Можно сделать вывод, что использование классов позволяет организовать программу так, чтобы она была более понятной и удобной для редактирования.