= Лабораторная работа 3-4
:author: Горшунова Мария Андреевна КЭ - 413
:description: Лабораторная работа 3-4 
:toc: 
:toclevels: 3
:toc-title: Оглавление
:sectnums: |,all|
:figure-caption: Рисунок
:imagesdir: PIC
:table-caption: Таблица

== Порты

Порт - это устройство для обмена данными (ввод и вывод). С помощью портов можно управлять работой других устройств. В микроконтроллере есть 5 портов общего назначения, 16 линий ввода/вывода.

== Порты общего назначения


=== Различные режимы работы портов

Порты могут работать в разных режимах:

* Плавющий цифровой вход (Input floating)
* Цифровой вход с подтяжкой к 1 (Input pull-up)
* Цифровой вход с подтяжкой к 0 (Input-pull-down)
* Аналоговый (Analog)
* Цифровой выход с открытым коллектором с подтяжкой к 1 или к 0 (Output open-drain with pull-up or pull-down capability)
* Цифровой двухтактный выход с подтяжкой к 1 или к 0 (Output push-pull with pull-up or pull-down capability) 
* Альтернативная функция с открытым коллектором с подтяжкой к 1 или к 0 (Alternate function push-pull with pull-up or pull-down capability)
* Альтернативная функция двухтактный выход с подтяжкой к 1 или к 0 (Alternate function open-drain with pull-up or pull-down capability)

=== Цифровой режим

В данном режиме порт имеет два состояния 1(*true*) и  0(*false*) или говоря на языке электроники *High* и *Low*. Эти сигналы соотвествуют уровню питания микроконтроллера, для нашего микроконтроллера обычно *High* соотвествует 3-3.3В, a *Low* - 0 В.

Когда порт настроен как цифровой выход им можно управлять. Например, если вы задали состояние порта High, то порт подключается к питанию, в итоге на ножке порта появляется высокий уровень напряжения. В случае, если вы задали Low, на ножке порта появляется низкий уровень напряжения или 0.

Когда порт настроен как цифровой вход его сопротивление бесконечно, контакт никуда не подключен ни к земле ни к питанию, поэтому ток никуда не течет. Любое напряжение
на такой ножке будет интерпретирована как 1 или 0, в зависимости от уровня напряжения высокого или низкого. В таком случае это называется "подвешенная" или плавающая ножка и наводка или шум на этой ножке может быть интерпретирован как 1 или 0 в зависимости от уровня шума. Таким образом такая плавающая "ножка" не очень хорошо, так как могут енерироваться
ложные переходы

=== Цифровой вход с подтяжкой

Плавающий сигнал на подвешенной ножке может быть причиной следующих проблем:

* Разное значение при считывании (1 или 0) в разные моменты времени;
* Ложные переходы (если настроено прерывание, то вы псотоянно будет входить в обработчик);
* Повышенно потребление из-за того, что схема входного буфера для ножки потребляет ток когда сигнал на ножке не полностью High или Low

Чтобы избавиться от плавющего сигнала на ножке обычно её подтягивают к 0 или 1.
Обычно эта опция уже есть внутри микроконтроллера и может быть настроена

=== Регистры портов общего назначения

* *GPIOx_MODER (port mode register)*.  Задает режимы работы индивидуально каждого из вывода порта. 
** Каждый из выводов GPIO может быть настроен как вход, выход, работать в аналоговом режиме, или подключен к одной из альтернативных функций. 

* *GPIOx_OSPEEDR (port output speed register)*. Задает скорость работы порта: 
** 400кГц, 2МГц, 10МГц и 40Мгц.

* *GPIOx_PUPDR (port pull-up/pull-down register)*. Задает подключение подтягивающих резисторов
** Без подтягивающего резистора, с подтяжкой к «+» питания, с подтяжкой к «gnd» земле. 

* *GPIOx_IDR (input data register)*. регистр входных данных, из которого считывается состояние входов порта.

* *GPIOx_ODR (output data register)*. регистр выходных данных. Запись числа в младшие 16 бит, приводит к появлению соответствующих уровней на выводах порта.

* *GPIOx_OTYPER (port output type register)*. В режиме выхода или альтернативной функции, соответствующий бит регистра устанавливает тип выхода. 
** Push-Pull (двухтактный) или Open Drain (выход с открытым коллектором).

* *GPIOx_BSRR (port bit set/reset register)*. Это регистр побитовой установки/сброса данных на выходных линиях порта.
** 32 разряда этого регистра позволяют индивидуально установить или сбросить каждый из 16 младших разрядов регистра *GPIOx_ODR*.

** Младшие 16 разрядов регистра *GPIOx_BSRR* отвечают за установку соответствующего бита регистра *GPIOx_ODR* в «1», старшие 16 разрядов сбрасывают этот бит. Установка/сброс осуществляются записью «1» в соответствующий разряд. Запись «0» никак не воздействует на состояние соответствующего бита выходного регистра данных. При одновременной записи двух единиц в биты установки и сброса, приоритет имеет операция установки бита.

* *GPIOxLCKR (port configuration lock register)*. Позволяет «заморозить», то есть защитить от изменения текущую настройку конфигурации. Можно запретить модификацию следующих регистров управления: *GPIOx_MODER*, *GPIOx_OTYPER*, *GPIOx_OSPEEDR*, *GPIOx_PUPDR*, *GPIOx_AFRL*,  *GPIOx_AFRH*.


== Включение светодиодов с помощью указателей

Указатель - это переменная, которая хранит адрес другой переменной. Указатели используются для управления памятью, взаимодействия с динамически выделяемыми данными, а также для эффективной передачи больших объектов или работы с массивами.

Напишем код который, поочередно включает светодиоды в порядке "елочки" — от LED1 до LED4, а затем в обратном порядке их выключение.

Светодиоды расположены на двух портах (GPIOA и GPIOC). На порте GPIOC находятся 3 светодиода, подключенные к битам 5, 8 и 9, а на порте GPIOA - 1 светодиод, подключенный к биту 5.

[source, cpp]
----
// Битовые маски
const std::uint32_t maskBit5 = (1U << 5U);
const std::uint32_t maskBit8 = (1U << 8U);
const std::uint32_t maskBit9 = (1U << 9U);

// Указание адресов портов
std::uint32_t* const prtGpiocOdr = reinterpret_cast<uint32_t*>(0x40020814U); // Порт GPIOC
std::uint32_t* const prtGpioaOdr = reinterpret_cast<uint32_t*>(0x40020014U); // Порт GPIOA

for(;;)
{
    // Включение светодиодов
    *prtGpioaOdr |= maskBit5; // Светодиод LED1
    delay(1000000);

    *prtGpiocOdr |= maskBit9; // Светодиод LED2
    delay(1000000);

    *prtGpiocOdr |= maskBit8; // Светодиод LED3
    delay(1000000);

    *prtGpiocOdr |= maskBit5; // Светодиод LED4
    delay(1000000);

    // Выключение светодиодов
    *prtGpioaOdr &= ~maskBit5; // Светодиод LED1
    delay(1000000);

    *prtGpiocOdr &= ~maskBit9; // Светодиод LED2
    delay(1000000);

    *prtGpiocOdr &= ~maskBit8; // Светодиод LED3
    delay(1000000);

    *prtGpiocOdr &= ~maskBit5; // Светодиод LED4
    delay(1000000);

    return 1;
}
----

Для расширения функциональных возможностей кода и упрощения его последующего редактирования и использования, мы воспользуемся другим подходом — реализуем класс.

== Включение светодиодов с помощью класса

Класс — это конструкция, которая позволяет объединить данные и методы (функции), работающие с этими данными, в одну логическую единицу. Класс является основой объектно-ориентированного программирования (ООП) и служит для создания объектов. Он описывает структуру и поведение объектов, а также инкапсулирует их внутреннее состояние.

Создадим класс обекта светодиод "Led":

[source, cpp]
----
// Создание виртуального класса
class ILed
{
    virtual void Light() = 0;
    virtual void Off() = 0;
    virtual void Toggle() = 0;
};

// Создание класса Led
class Led : public ILed
{
public:
    Led(std::uint32_t registerAddres, std::uint32_t pinNumber) : 
    registerAddr(registerAddres), pinNum(pinNumber) // Конструктор
    {
    }

void Light() override // Функция включения светодиода
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) |= (1 << pinNum);
    }
    void Off() override // Функция выключения светодиода
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) &= ~(1 << pinNum);
    }
    void Toggle() override // Функция изменения состояния светодиода на противоположное
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) ^= (1 << pinNum);
    }
private:
    std::uint32_t registerAddr; // Адрес указываемого регистра (порта)
    std::uint32_t pinNum; // Номер указываемого номера бита
};
----

Этот код создает интерфейс ILed, который определяет абстрактные методы для управления светодиодами: включение, выключение и переключение состояния. Класс Led реализует этот интерфейс, предоставляя конкретные функции для управления светодиодом через прямые манипуляции с регистрами микроконтроллера. Используются побитовые операции для включения, выключения и переключения состояния светодиода на заданном пине. Адрес регистра и номер пина передаются в конструктор класса.

Ниже написан код с зажиганием светодиодов "елочкой":

[source, cpp]
----
// Битовые маски
constexpr std::uint32_t maskBit5 = (1U << 5U);
constexpr std::uint32_t maskBit8 = (1U << 8U);
constexpr std::uint32_t maskBit9 = (1U << 9U);
// Указание портов
constexpr std::uint32_t gpiocOdrRegAddres = 0x40020814U;
constexpr std::uint32_t gpioaOdrRegAddres = 0x40020014U;
// Указатели
auto const gpioaOdrPtr = reinterpret_cast<std::uint32_t*>(gpioaOdrRegAddres);
auto const gpiocOdrPtr = reinterpret_cast<std::uint32_t*>(gpiocOdrRegAddres);

// Указание элементам массива (светодиодам) порта и бита
Led led1(gpioaOdrRegAddres, 5);
Led led2(gpiocOdrRegAddres, 9);
Led led3(gpiocOdrRegAddres, 8);
Led led4(gpiocOdrRegAddres, 5);

// Создание массива светодиодов
std::array<Led*, 4> leds = {
    &led1,
    &led2,
    &led3,
    &led4};

for(;;)
{
    for(auto it: leds)
    {
        it->Toggle(); // Включение/выключение светодиода
        delay(1000000);
    }
    
    return 1;
}
----

Таким образом, длинный и сложный код, написанный в начале работы, был сокращен до двух строк, выполняющих ту же задачу. Кроме того, такой подход значительно упрощает редактирование и расширение функциональности кода.

== Реализация других режимов включения светодиодов

В ходе лабораторной работы были также рассмотрены варианты включения светодиодов: "елочкой" (уже разобран), все одновременно и в шахматном порядке.

Таким образом, возникает еще одна задача: помимо указания порта и бита светодиода необходимо также указывать режим их работы.

Ниже представленна UML-диаграмма, показывающая обновленную структуру программы.

.UML-диаграмма
image::Diagramma.jpg[]

На диаграмме показано, что функции включения/выключения светодиода (*Light, Off, Toggle*) реализованы с помощью отдельного класса (интерфейса). То есть, функции включения/выключения реализованы отдельно. В свою очередь, режимы работы светодиодов имеют два метода: обновление (*Update()*) и установление (*Init()*). Каждый из этих методов реализован отдельно в соответствующих классах режимов.

=== Зажигание светодиодов в шахматном порядке

Светодиоды необходимо зажигать попеременно, т.е. два горят, два не горят.

Поскольку каждый из создаваемых режимов имеет две основные функции: обновление и установление, следует создать виртуальный класс, объявляющий данные методы:

[source, cpp]
----
class IMode
    {
      virtual void Update() = 0; // Обновление режима
      virtual void Init() = 0; // Установление режима
    };
----

Далее идет реализация класса, включающего светодиоды в шахматном порядке (класс *ChessMode*).

[source, cpp]
----
using tLeds = std::array<ILed*, 4>; // Создание массива указателей на объекты виртуального класса

class ChessMode: public IMode
    {
    public:
      ChessMode(tLeds& ledsArr): leds(ledsArr)
      {
      }
      // Метод обновления режима
      void Update() override
      {
        for(auto it: leds)
        {
          it->Toggle();
        }
      }
      
      // Метод установления режима
      void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        for(auto i=0; i< leds.size(); ++i)
        {
          if ((i%2)==0) // Условие четности
          {
            leds[i]->Toggle();
          }
        }
      }
    private:
      tLeds& leds;
    };
----

Благодаря виртуальному классу, методы, по сути выполняющие одни и те же функции, могут быть применены для многих других создаваемых режимов.

=== Одновременное зажигание включение светодиодов

Реализуем другой режим работы светодиодов, позволяющий зажигать светодиоды одновременно и одновременно выключать их.

[source, cpp]
----
class AllMode:public IMode
 {
 public:
    AllMode(tLeds& ledsArr): leds(ledsArr)
    {
        
    }
      void Update() override
      {
        for(auto it: leds)
        {
          it->Toggle();
        }
      }
      
      void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        
      }
private:
 tLeds& leds;
 };
----

=== Зажигание светодиоды в режиме "елочки"

Ниже реализуем режим работы светодиодов "елочкой".

[source, cpp]
----
class TreeMode:public IMode
 {
 public:
    TreeMode(tLeds& ledsArr): leds(ledsArr)
    {
        
    }
      void Update() override
      {
         for(auto it: leds)
        {
          it->Light();
        }
        for(auto i=0; i< leds.size(); ++i)
        {
            leds[i]->Toggle();
        }
      }
        void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        for(auto i=0; i< leds.size(); ++i)
        {
            leds[i]->Toggle();
        }
      }
    private:
      tLeds& leds;
    };
----

Можно сделать вывод, что использование классов позволяет организовать программу так, чтобы она была более понятной и удобной для редактирования.