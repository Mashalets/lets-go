= Лабораторная работа 1 
Горшунова М.А., КЭ - 413
:description: Лабораторная работа 1
:toc:
:toc-title: Оглавление
:sectnums: |,all|
:figure-caption: Рисунок
:imagesdir: PIC
:table-caption: Таблица

== Процесс разработки ПО

Разработка программного обеспечения (ПО) - это код, который осуществляет те или иные вычислительные операции. ПО является совокупностью элементов, в которую входит исполняемый программный код, связанные библиотеки и документация. Оно создается в целях выполнения конкретных задач.

Разработка ПО включает в себя несколько этапов. Рассмотрим каждый из них.

. Планирование: на первом этом этапе формируются цели проекта, определяются основные задачи, ресурсы и сроки. Важно составить план работы, который включает определение ключевых этапов и распределение задач между участниками команды. Также анализируются риски, которые могут повлиять на выполнение проекта, и разрабатываются стратегии их минимизации.
. Анализ требований: второй этап, где происходит сбор и анализ требований к будущему программному обеспечению. Он включает в себя взаимодействие с заказчиком, пользователями и другими заинтересованными сторонами, чтобы понять, какие задачи должна решать программа и какие функции в ней должны быть. 
. Архитектура ПО: на третьем этапе определяется общая структура и организация программного обеспечения. Это как план постройки дома - здесь проектируются основные модули и компоненты программы, их взаимосвязь и взаимодействие. Хорошо спроектированная архитектура облегчает дальнейшую разработку, тестирование и модернизацию программы.
. Кодирование: это четвертый этап, на котором создается программный код. Пишут код на основе требований и архитектурных решений, принятых на предыдущих этапах. Кодирование можно рассматривать как реализацию всех идей и концепций, сформированных в результате анализа требований и проектирования архитектуры. Кодирование может происходить поэтапно - сначала разрабатываются основные модули, затем они интегрируются и тестируются.
. Тестирование: на последнем пятом этапе проверяется, насколько написанное программное обеспечение соответствует требованиям и работает ли оно корректно. Цель тестирования - выявить ошибки и другие проблемы, которые могли возникнуть в процессе разработки. Чем раньше будут обнаружены ошибки, тем дешевле и быстрее их исправить.

.Процесс разработки с точки зрения IAR Workbench
image::Процесс разработки с точки зрения IAR Workbench.png[]

=== Вывод по 1 разделу 

В результате этих этапов разрабатывается готовое к использованию программное обеспечение, которое соответствует заявленным требования и стабильно работает.

== Компиляция кода, линковка и загрузка

=== Компиляция

Компиляция - это программа, которая осуществляет перевод исходной программы в эквивалентную ей объектную программу на языке машинных команд или языке ассемблера. Этот процесс выполняется с помощью программы, и называется компилятором.

Компиляция кода осуществляется с помощью компилятора. Структурно процесс трансляции, выполненный компилятором, представлен на рисунке <<Схема процесса трансляции>>. В результате трансляции вы можете получить либо библиотечные файлы, которые можно будет использовать в других проектах, либо объектные файлы.

[#Схема процесса трансляции]
.Схема процесса трансляции
image::Схема процесса трансляции.png[]

=== Компоновка (линковка)

Компоновку кода выполняет линковщик. Структурно процесс компоновки с его помощью можно увидеть на <<Схема процесса компоновки>>.

[#Схема процесса компоновки]
.Схема процесса компоновки
image::Схема процесса компоновки.png[]

Линковщик принимает на вход несколько компонентов: внешние библиотеки, которые были собраны на этапе трансляции в других проектах, объектные файлы, полученные ранее, стандартные (встроенные) библиотеки C++, а также конфигурационный файл, описывающий настройки размещения кода и данных в адресном пространстве микроконтроллера. В результате работы компоновщика создается исполняемый файл, который можно запустить на микроконтроллере.

=== Запуск

Последний этап, представленный на рисунке <<Возможные варианты использования выходного файла>>, - это отладка. Компоновщик IAR создает файл в формате ELF, который содержит исполняемый образ программы. Этот файл можно использовать, для:

. Загрузки в систему отладки IAR-CSPY или в любой другой отладчик, например, GDB, который поддерживает формат ELF.
. Записи образа в ПЗУ микроконтроллера с помощью программатора.

[#Возможные варианты использования выходного файла]
.Возможные варианты использования выходного файла
image::Возможные варианты использования выходного файла.png[]

== Запуск кода на микроконтроллере 

Сразу после включения питания происходит инициализация указателя стека, который устанавливается на конечный адрес стека. Стек необходим для хранения локальных переменных, переходов между функциями и контекста прерываний, обеспечивая оперативное сохранение временных значений. Указатель стека указывает на последний байт последнего добавленного элемента и хранится в регистрах процессора.

При инициализации переменные устанавливаются в нулевые значения. После подачи питания на микроконтроллер регистр адреса команды указывает на адрес 0, и микроконтроллер начинает работу с начального адреса, в нашем случае это 0x08000000. По этому адресу расположена таблица векторов прерывания, и по начальному вектору выполняется команда инициализации указателя стека на его конечный адрес, после чего происходит переход к функции инициализации.

После этого вызывается функция main().

== Стек

Стек - это организация памяти, выполненная компоновщиком. На уровне микроконтроллера для работы со стеком есть специальные ассемблерные команды (например, PUSH - положить регистры в стек, и POP - взять из стека). Так же для сохранения и считывания данных из стека могут использоваться инструкции STR и LDR

В стеке сохраняются регистры при вызове подпрограммы или переходе в прерывание, чтобы можно было восстановить весь контекст и все переменные при возвращении в программу. Если в функции передается слишком много переменных и не хватает регистров, компилятор также разместит их на стеке. Локальные переменные функции создаются именно на стеке.

В реализации память для всех локальных переменных выделяется сразу, одним "кадром стека", в начале выполнения функции. Компилятор на этапе компиляции создает фиксированную карту расположения локальных переменных в этом кадре. При этом он может располагать локальные переменные в карте произвольным образом, основываясь на соображениях оптимизации, таких как выравнивание и экономия памяти.

=== Влияние размера стека на программу

Для начала разберем переполнение стека: если размер стека слишком мал и происходит множество вложенных вызовов функций или используются большие локальные массивы, может возникнуть переполнение стека. Это приведет к сбоям программы.

Дальше разберем оптимизацию: большой стек позволяет хранить больше локальных переменных и поддерживать глубокие вызовы функций, но при этом увеличивает потребление памяти. Важно найти оптимальный баланс между размером стека и его использованием.

=== Глобальные и локальные переменные

Глобальные переменные - это переменные, которые существуют глобально, объявленные вне функций и доступные для использования в любой части программы. Они создаются один раз и живут в течение всего времени выполнения программы. 

Локальные переменные, в свою очередь, объявляются внутри функций или блоков и доступны только внутри них. Они создаются при вызове функции и иcчезают после выхода из функции.

== Компоновщик

Компоновку кода выполняет линковщик. Линкер - это программа, которая объединяет несколько объектных файлов, созданных компилятором, в один исполняемый файл или библиотеку.

=== Влияние оптимизации на результат компиляции

Оптимизация воздействует на результат компиляции следующими способами:

* сокращает время выполнения программы;
* уменьшает использование ресурсов;
* повышает общую производительность системы;
* улучшает качество сгенерированного машинного кода;
* снижает размер кода.

== Ответы на вопросы

1) Дайте определение понятию "Интегрированная среда разработки".

Ответ: Интегрированная среда разработки (IDE) - комплекс программных средств, используемый программистами для разработки программного обеспечения.

2) Что такое компилятор и чем он отличается от транслятора?

Ответ: Компилятор - это программа, которая осуществляет перевод исходной программы в эквивалентную ей объектную программу на языке машинных команд или языке ассемблера. Компилятор отличается от транслятора тем, что его результирующая программа написана обязательно на языке машинных команд или языке ассемблера.

3) Что такое компоновщик и какие функции он выполняет?

Ответ: Компоновщик - инструментальная программа, которая производит компоновку: принимает на вход один или несколько объектных модулей и собирает из них исполняемый или библиотечный файл-модуль.

4) Почему важен процесс проектирования ПО какие задачи входят в этот процесс?

Ответ: проектирование ПО важно, потому что оно позволяет оценить затрачиваемые на это ресурсы до начала создания и позволяет избежать разногласий между заказчиком и исполнителем. В процесс проектирования входят: планирование; анализ требований; архитектура ПО; кодирование и тестирование.

5) Дорисуйте процесс разработки ПО, описанный на изображении Процесс разработки с точки зрения IAR Workbench с учетом итеративности связей в этом процессе

Ответ: -

6) Зачем нужна отладка и в каких случаях она применяется? Для чего применяются точки остановки?

Ответ: Отладчик - это программный инструмент, позволяющий программисту наблюдать за выполнением исследуемой программы, останавливать и перезапускать её, прогонять в замедленном темпе, изменять значения в памяти. Для устранения ошибок в приложении.
Точки остановки устанавливаются везде, где нужно приостановить выполнение отладчика. Например, для просмотра состояния переменных кода или стек вызовов в определенной точке останова.

7) Какие еще важные IAR workbench можно добавить в таблицу <<Характеристики IAR Embedded Workbench>>.

[#Характеристики IAR Embedded Workbench]
.Характеристики IAR Embedded Workbench
[options="header"]
|===
| Характеристика | IAR Embedded Workbench
| Языки | С/C++
|Стандарты языка | С++ 17 начиная с версии 8.40
|Оптимизация кода | Да, кроме condition_variable, future, mutex, shared_mutex, thread, поддержка atomic урезана и реализована только для типов для которых есть аппаратная поддержка atomic специальными командами в микроконтроллерах
|Контроль размера стека | Да
|Поддержка RTOS | Да
|Статический анализатор кода с набором правил | Да - MISRAC++2008, SECURITY,CERT, STDCHECKS
|Динамический анализ кода | C-RUN
|Сертификация и проверка соответствию стандартам безопасности |Сертификация на безопасность по стандартам IEC 61508 и ISO 26262 экспертной организацией TUV SUD – SIL3 сертификат
|Поддержка микроконтроллера STM32F411 RE| Полная
|===

Ответ: C-SPY отладчик предупреждает о переполнении стека. Менеджер проектов, облегчает контроль и управление рабочими модулями.

== Вывод

В данной лабораторной работе, я изучила подробно этапы разработки ПО, а также разобралась с запуском кода на микроконтроллере, и изучила все понятия, которые втретились мне при запуске.