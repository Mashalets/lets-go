:description: Лабораторная работа 8
:toc: 
:toclevels: 3
:toc-title: Оглавление
:sectnums: |,all|
:figure-caption: Рисунок
:imagesdir: PIC
:table-caption: Таблица

include::Tityale8.adoc[]

== Аналого-цифровой преобразователь 

Аналого-цифровой преобразователь — устройство, преобразующее входной аналоговый сигнал в дискретный код. Как правило, АЦП — электронное устройство, преобразующее напряжение в двоичный цифровой код. Тем не менее, некоторые неэлектронные устройства с цифровым выходом следует также относить к АЦП, например, некоторые типы преобразователей угол-код. Простейшим одноразрядным двоичным АЦП является компаратор.

=== Основные харатеристики АЦП
* Разрешение
** Разрядность
** Эффективная разрядность
* Передаточная характеристика АЦП
* Точность
* Нелинейность
* Ошибки квантования
* Частота дискретизации

=== Типы АЦП
* *АЦП прямого(параллельные АЦП) преобразования*
* *АЦП последовательного приближения*
* *Сигма-дельта АЦП*
* АЦП дифференциального кодирования
* АЦП сравнения с пилообразным сигналом
* АЦП с уравновешиванием заряда
* Оптические АЦП

=== АПП микроконтроллера STM32F411

*АЦП(макс 12 разрядов)* микроконтроллера STM32F411 работает по принципу *последовательного приближения*.

* Основные элементы АЦП:
** Наличие регулярных и инжектированных каналов – отличие только в том, что инжектированные каналы могут писать данные в 4 регистра с 4 каналов сразу, а регулярный только в один регистр
** 19  аналоговых каналов,  16 из которых которые могут сконфигурированы на работу от внешних источников или 3 внутренних.
** Внешние каналы поступают на мультиплексор, где выбирается только один из них. Т.е. в один момент времени может быть измерено напряжение только с одного канала.
** Результат преобразования сохраняется в регистрах данных. Для регулярных каналов это только один 16 битный регистр. Для инжектированных – 4.
** Запуск преобразования может быть как программным, так и внешним. Внешний запуск может происходить от таймеров или с двух внешних входов.

=== Особенности АЦП микроконтроллера STM32F411

* Разрядность АЦП можно изменять
** 6, 8, 10, или 12 разрядов.
* Для одного канала можно задать разные режимы:
** однократно измерить аналоговую величину
** запустить канал в режиме непрерывного измерения.
* Режим сканирования
** Можно задать группу каналов и  порядок следования каналов в группе. Тогда измерения будут идти последовательно друг за другом, входной мультиплексор будет подключать внешние каналы к АЦП по очереди, в соответствии с запрограммированным порядком.
* Функция внешнего запуска для регулярных и инжектированных каналов.
* Режим “прерывистых” преобразований.
* Время одного преобразования зависит от частоты тактирования АЦП и времени скорости дискретизации , которое можно настроить.
** Tconv = Sampling time + 12 cycles. При 1 МГц, а время дискритизации 3 циклам, то полное время преобразование будет 15 тактов или 15 мкс.
* Размах входного сигнала не должен выходить за пределы опорного напряжения Vref.
* Возможность введения временной задержки, автоматически вставляемой между преобразованиями. Длительность задержки программируется.
* Генерация запроса для прямого доступа к памяти (режим DMA) во время преобразования в регулярном канале.

== Управляющие регистры

Для настройки и контроля работы АЦП STM32F411 используются специальные регистры. Ниже перечислены основные из них, их назначение и ключевые параметры.

*Регистр статуса SR (ADC status register)*

Этот регистр содержит флаги, которые отражают текущее состояние АЦП. Основной флаг — EOC (End of Conversion), который сигнализирует о завершении преобразования. Также присутствуют флаги для аналогового сторожа (AWD), переполнения (OVR), и начала преобразования (STRT).

*Регистр управления CR1 (ADC control register 1)*

Регистр ADC_CR1 задаёт основные параметры, такие как разрядность преобразования (RES[1:0]), режим сканирования каналов (SCAN), и включение прерываний для различных событий, таких как завершение преобразования (EOCIE) или переполнение данных (OVRIE).

*Регистр управления CR2 (ADC control register 2)*

В этом регистре задаются ключевые параметры запуска и режимы работы АЦП. Здесь можно включить модуль АЦП (ADON), настроить непрерывный или одиночный режим работы (CONT), а также выбрать внешние триггеры для запуска преобразования и активный фронт (EXTSEL, EXTEN).

*Регистр установки времени дискретизации SMPRx (ADC sample time register)*

Регистры ADC_SMPR1 и ADC_SMPR2 настраивают время выборки для каждого канала. Время выборки влияет на точность измерений и должно быть настроено в зависимости от источника сигнала и его сопротивления.

*Регистр определения последовательности преобразований SQR (ADC regular sequence register)*

Регистр ADC_SQR используется для задания порядка и количества каналов в регулярной группе преобразований. Для одиночного преобразования достаточно настроить один канал в ADC_SQR3 и установить длину последовательности в L=0.

*Регистр данных DR (ADC data register)*

В регистре ADC_DR хранится результат последнего завершённого преобразования. При выравнивании вправо (ALIGN=0) результат занимает младшие 12 бит регистра. Чтение из этого регистра сбрасывает флаг завершения преобразования (EOC).

*Общий регистр управления CCR (ADC common control register)*

Регистр ADC_CCR задаёт общие настройки, такие как предделитель тактовой частоты (ADCPRE[1:0]), включение питания для внутреннего датчика температуры и опорного напряжения (TSVREFE), а также разрешение измерения напряжения батареи (VBATE)

== Порядок запуска одиночного преобразования

. Подключение АЦП к источнику тактирования:

* Устанавливаем бит `ADC1EN` в регистре `RCC_APB2ENR` для включения тактирования АЦП от шины APB2.

. Конфигурация портов:

* Определяем каналы для измерений, затем на соответствующих выводах портов настраиваем аналоговый режим.  Для этого в регистре `GPIOx_MODER` устанавливаем биты `11₂` для каждого нужного пина.

. Конфигурация АЦП:

* Устанавливаем разрядность АЦП в регистре `ADC_CR1` с помощью бита `RES` (например, `00` для 12 бит).
* Включаем режим одиночного преобразования, установив в регистре `ADC_CR1` биты:
** `CONT = 0` (одиночное преобразование),
** `EOCS` — настраиваем в зависимости от требований (например, для завершения преобразования).

. Настройка очереди канала для преобразования:

* В регистре `ADC_SQR1` устанавливаем бит `L = 0` для одного измерения.
* В регистре `ADC_SQR3` задаём номер канала для первого преобразования с помощью бита `SQ1`.

. Настройка времени выборки:

* В регистре `ADC_SMPR1` или `ADC_SMPR2` в зависимости от выбранного канала задаём соответствующие биты `SMP[2:0]` для настройки времени выборки (например, 15 тактов для низкоомных источников, 480 тактов для высокоомных).

. Включение АЦП:

* Устанавливаем бит `ADON` в регистре `ADC_CR2` для включения АЦП.
* Даем небольшую задержку (несколько микросекунд) для стабилизации работы модуля.

. Запуск преобразования:

* Для запуска преобразования устанавливаем бит `SWSTART` в регистре `ADC_CR2` для регулярных каналов.

. Ожидание завершения преобразования (EOC):

* Проверяем бит `EOC` (End of Conversion) в регистре `ADC_SR`. Как только бит устанавливается в 1, преобразование завершено.

. Чтение результата:

* Считываем результат из регистра `ADC_DR`. При выравнивании вправо (если `ALIGN = 0`) результат будет находиться в младших 12 битах регистра.

Процесс настройки одиночного преобразования АЦП представляет собой последовательность шагов, включающих подключение тактирования, настройку портов, конфигурацию самого АЦП, выбор канала, настройку времени выборки, запуск преобразования и чтение результатов. Важно учитывать все необходимые параметры, такие как разрядность, режим работы, время выборки и правильную настройку очереди каналов, чтобы обеспечить точность и корректность измерений. После выполнения всех настроек АЦП можно использовать для получения цифровых данных с аналоговых сигналов, которые можно далее обрабатывать в программе.

== Измерение температуры 

В STM32F411 имеется встроенный датчик температуры, подключённый к каналу ADC_IN18. Он позволяет измерять температуру кристалла МК (а не окружающей среды) и обычно используется для внутренних нужд:

. Включение датчика и настройка времени выборки

* Установить бит TSVREFE в регистре ADC_CCR, чтобы включить питание датчика температуры и внутреннего опорного напряжения.
* Задать максимальное время выборки (480 тактов, код 111) для канала 18, поскольку датчик имеет высокое выходное сопротивление.

. Выбор канала

* В `ADC_SQR3` выбрать канал 18 (SQ1=18), в `ADC_SQR1` 

. Запуск и чтение результата

* Установить бит ADON (ADC_CR2::ADON) для включения АЦП.
* Запустить преобразование битом SWSTART.
* Ждать флаг EOC (ADC_SR::EOC).
* Прочитать код из ADC_DR.

. Перевод кода в температуру

В официальном Reference Manual и Datasheet указана формула, учитывающая заводскую калибровку. Пример линейной интерполяции:

  T = 30°C + ( (Code_measured - TS_CAL1) / (TS_CAL2 - TS_CAL1) ) * (110°C - 30°C)

где:
 * TS_CAL1 — заводской калибровочный код при 30°C;
 * TS_CAL2 — заводской калибровочный код при 110°C.

Адреса калибровочных значений указаны в документации на конкретный чип. При чтении этих значений из памятью MК можно более точно вычислить температуру. В случае отсутствия точных калибровок используется упрощённая формула со средним наклоном (AvgSlope ~ 2.5 мВ/°C и V25 ~ 0.76 В при 25°C). 


Таким образом, измерение температуры кристалла внутри STM32F411 достаточно просто интегрируется в код, если учесть требования к времени выборки и включить питание датчика. Однако учитывайте, что показания отражают именно температуру кристалла, которая может заметно отличаться от внешней температуры. 

== Измерение напряжения на переменном резисторе

Измерение аналогового сигнала от потенциометра (переменного резистора) — классический пример использования АЦП. Обычно потенциометр подключается между питанием (3.3 В) и землёй, а середина (ползунок) идёт на вход АЦП.

. Подключение и настройка GPIO

* Убедиться, что выбранный вывод (например, PA0, соответствующий каналу 0 АЦП) переведён в аналоговый режим (MODER=11₂).
* Включить тактирование для порта A (бит GPIOAEN в RCC_AHB1ENR).

. Настройка АЦП

* Включить модуль ADC1 (RCC_APB2ENR::ADC1EN).
* Задать разрядность (12 бит), одиночный режим и выравнивание вправо (CR1 и CR2).
* Установить разумное время выборки в SMPR (например, 15 или 28 тактов), если источник низкоомный (потенциометр обычно несколько кОм).
* В SQR3 указать канал 0 (L=0, SQ1=0).
* Включить АЦП битом ADON.

. Выполнение преобразования

* Установить бит SWSTART (ADC_CR2::SWSTART).
* Дождаться флага EOC (ADC_SR::EOC).
* Считать результат из ADC_DR.

. Перевод результата в напряжение

Полученное 12-битное значение (0…4095) отражает уровень от 0 до VREF (часто 3.3 В). Для перевода в вольты:

  voltage = (ADC_CODE / 4095.0f) * VREF

Например, при VREF = 3.3 В, если код 2048, то напряжение ≈ 1.65 В (примерно половина диапазона).

Таким образом, считывая напряжение с ползунка потенциометра, можно легко определять текущее положение регулятора. Подобное же решение используется при подключении всевозможных аналоговых датчиков, выдающих напряжение в пределах 0…3.3 В.

== Заключение

В данной работе рассмотрен 12-битный АЦП типа SAR микроконтроллера STM32F411, который эффективно оцифровывает различные аналоговые сигналы, включая встроенный датчик температуры и внешние источники, такие как потенциометр. Основные моменты, на которые стоит обратить внимание, включают настройку регистров управления, времени выборки и последовательности каналов, а также правильное включение тактирования и перевод порта в аналоговый режим. АЦП поддерживает работу с несколькими каналами и специальный режим для внутреннего датчика температуры, требует корректного времени выборки для высокоомных источников и имеет поддержку DMA и прерываний, что упрощает обработку данных. Для удобства работы с АЦП полезно использовать класс, который скрывает низкоуровневые детали настройки и предоставляет методы для чтения данных, что улучшает читаемость и надёжность кода. В целом, правильно настроенный АЦП позволяет эффективно работать с широким спектром аналоговых датчиков и сигналов, предоставляя гибкость и функциональность для различных встроенных приложений.

[source,cpp]
----
#include "rccregisters.hpp"    // for RCC
#include "gpioaregisters.hpp"  // for GPIOA
#include "gpiocregisters.hpp"  // for GPIOC
#include <array>
#include <cstdint>
#include "adc1registers.hpp"   // for ADC CR1
#include <iostream>

#include "stkregisters.hpp"    // for SystemTimer
#include "scbregisters.hpp"    // for ISCR register
#include "tim2registers.hpp"

#include "ILed.h"
#include "Led.h"
#include "ledconfig.h"

#include "IMode.h"
#include "allmode.h"
#include "treemode.h"
#include "chessmode.h"
#include "modeconfig.h"
#include "IButton.h"
#include "Button.h"
#include "IModeManager.h"
#include "modeconfig.h"
#include "ModeManager.h"
#include "ButtonExti.h"
#include "ModeManagerConfig.h"
#include "syscfgregisters.hpp"
#include "extiregisters.hpp"
#include "nvicregisters.hpp"   // for NVIC
#include "tim5registers.hpp"   // for TIM5

std::uint32_t SystemCoreClock = 8'000'000U;

extern "C" {
int __low_level_init(void)
{
  RCC::CR::HSION::On::Set();
  // while (RCC::CR::HSIRDY::NotReady::IsSet()) { }
  RCC::CFGR::SW::Hsi::Set();
  // while (!RCC::CFGR::SWS::Hsi::IsSet()) { }

  RCC::APB2ENR::SYSCFGEN::Enable::Set();
  STK::CTRL::CLKSOURCE::CpuClock::Set();
  RCC::APB1ENR::TIM5EN::Enable::Set();

  NVIC::ISER1::Write(1 << 18U);

  const auto TimerDivider = SystemCoreClock / 1'000U;

  TIM5::PSC::Write(TimerDivider);
  TIM5::CR1::URS::Value1::Set();
  TIM5::ARR::Write(500U);
  TIM5::SR::UIF::Set(0);
  TIM5::CNT::Write(0);
  TIM5::DIER::UIE::Value1::Set();
  TIM5::CR1::CEN::Enable::Set();

  return 1;
}
}

bool isInterruptHappened = false;

int main()
{
  RCC::AHB1ENR::GPIOAEN::Enable::Set();

  RCC::AHB1ENR::GPIOCEN::Enable::Set();

  GPIOA::MODER::MODER5::Output::Set();
  GPIOC::MODER::MODER5::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();


  ButtonExti<GPIOC, 13> button;

  Led<GPIOC, 5> led1;
  Led<GPIOC, 8> led2;
  Led<GPIOC, 9> led3;
  Led<GPIOA, 5> led4;

  tLeds leds = { &led1, &led2, &led3, &led4 };


  AllMode allmode(leds);
  ChessMode chessmode(leds);
  TreeMode treemode(leds);

  tMode MODES = {
    &allmode,
    &chessmode,
    &treemode
  };

  ModeManager modeManager(MODES);
  modeManager.InitModeManager();

  for(;;)
  {
    if (isInterruptHappened)
    {
    
      modeManager.UpdateModeManager();
      if(button.onClick())
      {
        modeManager.SwitchModeManager();
      }
      isInterruptHappened = false;
    }
  }

  return 1;
}
----